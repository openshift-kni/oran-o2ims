// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
	externalRef0 "github.com/openshift-kni/oran-o2ims/internal/service/common/api/generated"
)

// Defines values for AlarmDefinitionAlarmChangeType.
const (
	ADDED    AlarmDefinitionAlarmChangeType = "ADDED"
	DELETED  AlarmDefinitionAlarmChangeType = "DELETED"
	MODIFIED AlarmDefinitionAlarmChangeType = "MODIFIED"
)

// Defines values for AlarmDefinitionClearingType.
const (
	AUTOMATIC AlarmDefinitionClearingType = "AUTOMATIC"
	MANUAL    AlarmDefinitionClearingType = "MANUAL"
)

// Defines values for AlarmDefinitionManagementInterfaceId.
const (
	AlarmDefinitionManagementInterfaceIdO2IMS AlarmDefinitionManagementInterfaceId = "O2IMS"
)

// Defines values for AlarmDictionaryManagementInterfaceId.
const (
	AlarmDictionaryManagementInterfaceIdO2IMS AlarmDictionaryManagementInterfaceId = "O2IMS"
)

// Defines values for InventoryChangeNotificationNotificationEventType.
const (
	N0 InventoryChangeNotificationNotificationEventType = 0
	N1 InventoryChangeNotificationNotificationEventType = 1
	N2 InventoryChangeNotificationNotificationEventType = 2
)

// Defines values for ResourceTypeResourceClass.
const (
	ResourceTypeResourceClassCOMPUTE    ResourceTypeResourceClass = "COMPUTE"
	ResourceTypeResourceClassNETWORKING ResourceTypeResourceClass = "NETWORKING"
	ResourceTypeResourceClassSTORAGE    ResourceTypeResourceClass = "STORAGE"
	ResourceTypeResourceClassUNDEFINED  ResourceTypeResourceClass = "UNDEFINED"
)

// Defines values for ResourceTypeResourceKind.
const (
	ResourceTypeResourceKindLOGICAL   ResourceTypeResourceKind = "LOGICAL"
	ResourceTypeResourceKindPHYSICAL  ResourceTypeResourceKind = "PHYSICAL"
	ResourceTypeResourceKindUNDEFINED ResourceTypeResourceKind = "UNDEFINED"
)

// AlarmDefinition Information about an alarm definition.
type AlarmDefinition struct {
	// AlarmAdditionalFields List of metadata key-value pairs used to associate meaningful metadata to the related resource type.
	AlarmAdditionalFields map[string]interface{} `json:"alarmAdditionalFields"`

	// AlarmChangeType Indicates the type of change that occurred during the alarm last change; added, deleted, modified.
	AlarmChangeType AlarmDefinitionAlarmChangeType `json:"alarmChangeType"`

	// AlarmDefinitionId Provides a unique identifier of the alarm being raised. This is the Primary Key into the Alarm Dictionary
	AlarmDefinitionId openapi_types.UUID `json:"alarmDefinitionId"`

	// AlarmDescription Provides a longer descriptive meaning of the alarm condition and a description of the consequences of the
	// alarm condition. This is intended to be read by an operator to give an idea of what happened and a sense of
	// the effects, consequences, and other impacted areas of the system.
	AlarmDescription string `json:"alarmDescription"`

	// AlarmLastChange Indicates the Alarm Dictionary Version in which this alarm last changed.
	AlarmLastChange string `json:"alarmLastChange"`

	// AlarmName Provides short name for the alarm
	AlarmName string `json:"alarmName"`

	// ClearingType Identifies whether alarm is cleared automatically or manually.
	ClearingType AlarmDefinitionClearingType `json:"clearingType"`

	// ManagementInterfaceId List of management interface over which alarms are transmitted for this Entity Type.
	// RESTRICTION: For the O-Cloud IMS Services this value is limited to O2IMS.
	ManagementInterfaceId []AlarmDefinitionManagementInterfaceId `json:"managementInterfaceId"`

	// PkNotificationField Identifies which field or list of fields in the alarm notification contains the primary key (PK) into the
	// Alarm Dictionary for this interface; i.e. which field contains the Alarm Definition ID.
	PkNotificationField []string `json:"pkNotificationField"`

	// ProposedRepairActions Provides guidance for proposed repair actions.
	ProposedRepairActions string `json:"proposedRepairActions"`
}

// AlarmDefinitionAlarmChangeType Indicates the type of change that occurred during the alarm last change; added, deleted, modified.
type AlarmDefinitionAlarmChangeType string

// AlarmDefinitionClearingType Identifies whether alarm is cleared automatically or manually.
type AlarmDefinitionClearingType string

// AlarmDefinitionManagementInterfaceId defines model for AlarmDefinition.ManagementInterfaceId.
type AlarmDefinitionManagementInterfaceId string

// AlarmDictionary Information about an alarm dictionary.
type AlarmDictionary struct {
	AlarmDefinition []AlarmDefinition `json:"alarmDefinition"`

	// AlarmDictionarySchema Version of the Alarm Dictionary Schema to which this alarm dictionary conforms.
	AlarmDictionarySchema string `json:"alarmDictionarySchema"`

	// AlarmDictionaryVersion Version of the Alarm Dictionary. Version is vendor defined such that the version of the dictionary can be
	// associated with a specific version of the software delivery of this product.
	AlarmDictionaryVersion string `json:"alarmDictionaryVersion"`

	// EntityType O-RAN entity type emitting the alarm: This shall be unique per vendor ResourceType.model and
	// ResourceType.version
	EntityType string `json:"entityType"`

	// ManagementInterfaceId List of management interface over which alarms are transmitted for this Entity Type.
	// RESTRICTION: For the O-Cloud IMS Services this value is limited to O2IMS.
	ManagementInterfaceId []AlarmDictionaryManagementInterfaceId `json:"managementInterfaceId"`

	// PkNotificationField Identifies which field or list of fields in the alarm notification contains the primary key (PK) into the
	// Alarm Dictionary for this interface; i.e. which field contains the Alarm Definition ID.
	PkNotificationField []string `json:"pkNotificationField"`

	// Vendor Vendor of the Entity Type to whom this Alarm Dictionary applies. This should be the same value as in the
	// ResourceType.vendor attribute
	Vendor string `json:"vendor"`
}

// AlarmDictionaryManagementInterfaceId defines model for AlarmDictionary.ManagementInterfaceId.
type AlarmDictionaryManagementInterfaceId string

// DeploymentManager Information about a deployment manager.
type DeploymentManager struct {
	// Capabilities Information about the capabilities supported by the Deployment Manager and its set of deployment management
	// services based on the resources allocated to the Deployment Manager.
	Capabilities map[string]string `json:"capabilities"`

	// Capacity Information about the available, allocated and reserved capacity of O-Cloud Resources allocated to the
	// Deployment Manager.
	Capacity map[string]string `json:"capacity"`

	// DeploymentManagerId Identifier for the Deployment Manager. This identifier is allocated by the O-Cloud.
	DeploymentManagerId openapi_types.UUID `json:"deploymentManagerId"`

	// Description Human readable description of the deployment manager
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related Deployment Manager.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// Name Human readable description of the deployment manager
	Name string `json:"name"`

	// OCloudId Identifier for the containing O-Cloud.
	OCloudId openapi_types.UUID `json:"oCloudId"`

	// ServiceUri The fully qualified URI to a Deployment Management server for O2dms services. Since the O2dms provides
	// multiple services, this entry is for the {apiRoot} only.
	ServiceUri string `json:"serviceUri"`

	// SupportedLocations List of globalLocationIDs that were assigned to the OCloud Site(s) which this Deployment Manager supports.
	SupportedLocations []string `json:"supportedLocations"`
}

// InventoryChangeNotification Information about an inventory change notification
type InventoryChangeNotification struct {
	// ConsumerSubscriptionId The value provided by the consumer in the subscription
	ConsumerSubscriptionId *openapi_types.UUID `json:"consumerSubscriptionId,omitempty"`

	// NotificationEventType One of the following values: 0 - create, 1 - modify, 2 - delete
	NotificationEventType InventoryChangeNotificationNotificationEventType `json:"notificationEventType"`

	// NotificationId A unique identifier to represent this notification event
	NotificationId openapi_types.UUID `json:"notificationId"`

	// ObjectRef The URL to the object. This is not required if the notificationEventType is 2 (DELETE). It will point to
	// one of the following data types defined in clause 3.2.6 and the reference will match the type of objects
	// supplied in priorObjectState and/or postObjectState.
	ObjectRef *string `json:"objectRef,omitempty"`

	// PostObjectState This is required if the notificationEventType is 0 (CREATE) or 1 (MODIFY) and is one of the following data
	// types defined in clause 3.2.6 and will match the type of object in priorObjectState and/or the type
	// referred to in objectRef.
	PostObjectState *string `json:"postObjectState,omitempty"`

	// PriorObjectState This is required if the notificationEventType is 1 (MODIFY) or 2 (DELETE) and is one of the following
	// data types defined in clause 3.2.6 and will match the type of object in postObjectState and/or the type
	// referred to in objectRef.
	PriorObjectState *string `json:"priorObjectState,omitempty"`
}

// InventoryChangeNotificationNotificationEventType One of the following values: 0 - create, 1 - modify, 2 - delete
type InventoryChangeNotificationNotificationEventType int

// OCloudInfo defines model for OCloudInfo.
type OCloudInfo struct {
	// Description Human readable description of the O-Cloud as provided by the SMO at cloud genesis.
	Description string             `json:"description"`
	Extensions  *map[string]string `json:"extensions,omitempty"`

	// GlobalCloudId Identifier of the O-Cloud instance assigned by the SMO. This identifier is globally unique across O-Cloud
	// instances known to the SMO. This value was provided by the SMO at cloud genesis and is stored in the O-Cloud
	// IMS Inventory.
	GlobalCloudId openapi_types.UUID `json:"globalCloudId"`

	// Name Human readable name of the O-Cloud as identified by the SMO at cloud genesis.
	Name string `json:"name"`

	// OCloudId Identifier of the O-Cloud instance. Internally generated within an O-Cloud instance.
	OCloudId openapi_types.UUID `json:"oCloudId"`

	// ServiceUri The URI root to all services provided by the O2ims interface. Inventory is one of these services.
	ServiceUri string `json:"serviceUri"`
}

// Resource Information about a resource.
type Resource struct {
	// Description Human readable description of the resource.
	Description string `json:"description"`

	// Elements The resource might be composed of smaller resources or other resource instances of a different type
	Elements []Resource `json:"elements"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource.
	Extensions map[string]string `json:"extensions"`

	// GlobalAssetId Identifier or serial number of the resource, if available. It is required only if the resource has been
	// identified during its addition to the cloud as a reportable asset in the SMO inventory.
	GlobalAssetId string `json:"globalAssetId"`

	// Groups Keywords denoting groups a resource belongs to.
	Groups []string `json:"groups"`

	// ResourceId Identifier for the Resource. This identifier is allocated by the O-Cloud.
	ResourceId     openapi_types.UUID `json:"resourceId"`
	ResourcePoolId openapi_types.UUID `json:"resourcePoolId"`

	// ResourceTypeId Identifier for the Resource Type of this resource.
	ResourceTypeId openapi_types.UUID `json:"resourceTypeId"`

	// Tags Keywords describing or classifying the resource instance
	Tags []string `json:"tags"`
}

// ResourcePool Information about a resource pool.
type ResourcePool struct {
	// Description Human readable description of the resource pool.
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource pool.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// GlobalLocationId This identifier is copied from the O-Cloud Id assigned by the SMO during the O-Cloud deployment
	GlobalLocationId openapi_types.UUID `json:"globalLocationId"`

	// Location Information about the geographical location of the resource pool as detected by the O-Cloud.
	Location *string `json:"location,omitempty"`

	// Name Human readable name of the resource pool.
	Name string `json:"name"`

	// OCloudId Identifier for the containing O-Cloud.
	OCloudId openapi_types.UUID `json:"oCloudId"`

	// ResourcePoolId Identifier for the Resource Pool in the O-Cloud instance. This identifier is allocated by the O-Cloud.
	ResourcePoolId openapi_types.UUID `json:"resourcePoolId"`
}

// ResourceType Information about a resource type.
type ResourceType struct {
	AlarmDictionary map[string]interface{} `json:"alarmDictionary"`

	// Description Human readable description of the resource type.
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource type.
	Extensions map[string]string `json:"extensions"`

	// Model Information about the model of the resource as defined by its provider.
	Model string `json:"model"`

	// Name Human readable name of the resource type.
	Name string `json:"name"`

	// ResourceClass Functional role of the resource type within the cloud.
	ResourceClass ResourceTypeResourceClass `json:"resourceClass"`

	// ResourceKind Value describing “physicality” of the resource type.
	ResourceKind ResourceTypeResourceKind `json:"resourceKind"`

	// ResourceTypeId Identifier for the Resource Type. This identifier is allocated by the O-Cloud.
	ResourceTypeId openapi_types.UUID `json:"resourceTypeId"`

	// Vendor Provider of the Resource.
	Vendor string `json:"vendor"`

	// Version Version or generation of the resource as defined by its provider.
	Version string `json:"version"`
}

// ResourceTypeResourceClass Functional role of the resource type within the cloud.
type ResourceTypeResourceClass string

// ResourceTypeResourceKind Value describing “physicality” of the resource type.
type ResourceTypeResourceKind string

// Subscription Information about an inventory subscription.
type Subscription struct {
	// Callback The fully qualified URI to a consumer procedure which can process a Post of the
	// InventoryEventNotification.
	Callback string `json:"callback"`

	// ConsumerSubscriptionId Identifier for the consumer of events sent due to the Subscription.
	ConsumerSubscriptionId *openapi_types.UUID `json:"consumerSubscriptionId,omitempty"`

	// Filter Criteria for events which do not need to be reported or will be filtered by the subscription
	// notification service. Therefore, if a filter is not provided then all events are reported.
	Filter *string `json:"filter,omitempty"`

	// SubscriptionId Identifier for the Subscription. This identifier is allocated by the O-Cloud.
	SubscriptionId *openapi_types.UUID `json:"subscriptionId,omitempty"`
}

// DeploymentManagerId defines model for deploymentManagerId.
type DeploymentManagerId = openapi_types.UUID

// ResourceId defines model for resourceId.
type ResourceId = openapi_types.UUID

// ResourcePoolId defines model for resourcePoolId.
type ResourcePoolId = openapi_types.UUID

// ResourceTypeId defines model for resourceTypeId.
type ResourceTypeId = openapi_types.UUID

// SubscriptionId defines model for subscriptionId.
type SubscriptionId = openapi_types.UUID

// GetCloudInfoParams defines parameters for GetCloudInfo.
type GetCloudInfoParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetDeploymentManagersParams defines parameters for GetDeploymentManagers.
type GetDeploymentManagersParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetDeploymentManagerParams defines parameters for GetDeploymentManager.
type GetDeploymentManagerParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetResourcePoolsParams defines parameters for GetResourcePools.
type GetResourcePoolsParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetResourcesParams defines parameters for GetResources.
type GetResourcesParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetResourceTypesParams defines parameters for GetResourceTypes.
type GetResourceTypesParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetSubscriptionsParams defines parameters for GetSubscriptions.
type GetSubscriptionsParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetSubscriptionParams defines parameters for GetSubscription.
type GetSubscriptionParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`
}

// CreateSubscriptionJSONRequestBody defines body for CreateSubscription for application/json ContentType.
type CreateSubscriptionJSONRequestBody = Subscription

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllVersions request
	GetAllVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudInfo request
	GetCloudInfo(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMinorVersions request
	GetMinorVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentManagers request
	GetDeploymentManagers(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentManager request
	GetDeploymentManager(ctx context.Context, deploymentManagerId DeploymentManagerId, params *GetDeploymentManagerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcePools request
	GetResourcePools(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcePool request
	GetResourcePool(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResources request
	GetResources(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceTypes request
	GetResourceTypes(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceType request
	GetResourceType(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptions request
	GetSubscriptions(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubscriptionWithBody request with any body
	CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubscription(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscription request
	DeleteSubscription(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscription request
	GetSubscription(ctx context.Context, subscriptionId SubscriptionId, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudInfo(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMinorVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMinorVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentManagers(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentManagersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentManager(ctx context.Context, deploymentManagerId DeploymentManagerId, params *GetDeploymentManagerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentManagerRequest(c.Server, deploymentManagerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcePools(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcePoolsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcePool(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcePoolRequest(c.Server, resourcePoolId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResources(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcesRequest(c.Server, resourcePoolId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, resourcePoolId, resourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceTypes(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceType(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypeRequest(c.Server, resourceTypeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptions(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscription(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscription(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscription(ctx context.Context, subscriptionId SubscriptionId, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionRequest(c.Server, subscriptionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllVersionsRequest generates requests for GetAllVersions
func NewGetAllVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/api_versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCloudInfoRequest generates requests for GetCloudInfo
func NewGetCloudInfoRequest(server string, params *GetCloudInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMinorVersionsRequest generates requests for GetMinorVersions
func NewGetMinorVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/api_versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentManagersRequest generates requests for GetDeploymentManagers
func NewGetDeploymentManagersRequest(server string, params *GetDeploymentManagersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/deploymentManagers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentManagerRequest generates requests for GetDeploymentManager
func NewGetDeploymentManagerRequest(server string, deploymentManagerId DeploymentManagerId, params *GetDeploymentManagerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deploymentManagerId", runtime.ParamLocationPath, deploymentManagerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/deploymentManagers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcePoolsRequest generates requests for GetResourcePools
func NewGetResourcePoolsRequest(server string, params *GetResourcePoolsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcePoolRequest generates requests for GetResourcePool
func NewGetResourcePoolRequest(server string, resourcePoolId ResourcePoolId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcesRequest generates requests for GetResources
func NewGetResourcesRequest(server string, resourcePoolId ResourcePoolId, params *GetResourcesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s/resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, resourcePoolId ResourcePoolId, resourceId ResourceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s/resources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypesRequest generates requests for GetResourceTypes
func NewGetResourceTypesRequest(server string, params *GetResourceTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourceTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypeRequest generates requests for GetResourceType
func NewGetResourceTypeRequest(server string, resourceTypeId ResourceTypeId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceTypeId", runtime.ParamLocationPath, resourceTypeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourceTypes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionsRequest generates requests for GetSubscriptions
func NewGetSubscriptionsRequest(server string, params *GetSubscriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubscriptionRequest calls the generic CreateSubscription builder with application/json body
func NewCreateSubscriptionRequest(server string, body CreateSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubscriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSubscriptionRequestWithBody generates requests for CreateSubscription with any type of body
func NewCreateSubscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscriptionRequest generates requests for DeleteSubscription
func NewDeleteSubscriptionRequest(server string, subscriptionId SubscriptionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionRequest generates requests for GetSubscription
func NewGetSubscriptionRequest(server string, subscriptionId SubscriptionId, params *GetSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllVersionsWithResponse request
	GetAllVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVersionsResponse, error)

	// GetCloudInfoWithResponse request
	GetCloudInfoWithResponse(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*GetCloudInfoResponse, error)

	// GetMinorVersionsWithResponse request
	GetMinorVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMinorVersionsResponse, error)

	// GetDeploymentManagersWithResponse request
	GetDeploymentManagersWithResponse(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagersResponse, error)

	// GetDeploymentManagerWithResponse request
	GetDeploymentManagerWithResponse(ctx context.Context, deploymentManagerId DeploymentManagerId, params *GetDeploymentManagerParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagerResponse, error)

	// GetResourcePoolsWithResponse request
	GetResourcePoolsWithResponse(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*GetResourcePoolsResponse, error)

	// GetResourcePoolWithResponse request
	GetResourcePoolWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*GetResourcePoolResponse, error)

	// GetResourcesWithResponse request
	GetResourcesWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetResourceTypesWithResponse request
	GetResourceTypesWithResponse(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*GetResourceTypesResponse, error)

	// GetResourceTypeWithResponse request
	GetResourceTypeWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error)

	// GetSubscriptionsWithResponse request
	GetSubscriptionsWithResponse(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error)

	// CreateSubscriptionWithBodyWithResponse request with any body
	CreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	CreateSubscriptionWithResponse(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	// DeleteSubscriptionWithResponse request
	DeleteSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error)

	// GetSubscriptionWithResponse request
	GetSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error)
}

type GetAllVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.APIVersions
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAllVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudInfoResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OCloudInfo
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetCloudInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMinorVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.APIVersions
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetMinorVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMinorVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentManagersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]DeploymentManager
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDeploymentManagersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentManagersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentManagerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DeploymentManager
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDeploymentManagerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentManagerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcePoolsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]ResourcePool
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcePoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcePoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcePoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResourcePool
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]Resource
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Resource
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]ResourceType
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResourceType
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]Subscription
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *Subscription
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Subscription
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllVersionsWithResponse request returning *GetAllVersionsResponse
func (c *ClientWithResponses) GetAllVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVersionsResponse, error) {
	rsp, err := c.GetAllVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllVersionsResponse(rsp)
}

// GetCloudInfoWithResponse request returning *GetCloudInfoResponse
func (c *ClientWithResponses) GetCloudInfoWithResponse(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*GetCloudInfoResponse, error) {
	rsp, err := c.GetCloudInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudInfoResponse(rsp)
}

// GetMinorVersionsWithResponse request returning *GetMinorVersionsResponse
func (c *ClientWithResponses) GetMinorVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMinorVersionsResponse, error) {
	rsp, err := c.GetMinorVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMinorVersionsResponse(rsp)
}

// GetDeploymentManagersWithResponse request returning *GetDeploymentManagersResponse
func (c *ClientWithResponses) GetDeploymentManagersWithResponse(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagersResponse, error) {
	rsp, err := c.GetDeploymentManagers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentManagersResponse(rsp)
}

// GetDeploymentManagerWithResponse request returning *GetDeploymentManagerResponse
func (c *ClientWithResponses) GetDeploymentManagerWithResponse(ctx context.Context, deploymentManagerId DeploymentManagerId, params *GetDeploymentManagerParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagerResponse, error) {
	rsp, err := c.GetDeploymentManager(ctx, deploymentManagerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentManagerResponse(rsp)
}

// GetResourcePoolsWithResponse request returning *GetResourcePoolsResponse
func (c *ClientWithResponses) GetResourcePoolsWithResponse(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*GetResourcePoolsResponse, error) {
	rsp, err := c.GetResourcePools(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcePoolsResponse(rsp)
}

// GetResourcePoolWithResponse request returning *GetResourcePoolResponse
func (c *ClientWithResponses) GetResourcePoolWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*GetResourcePoolResponse, error) {
	rsp, err := c.GetResourcePool(ctx, resourcePoolId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcePoolResponse(rsp)
}

// GetResourcesWithResponse request returning *GetResourcesResponse
func (c *ClientWithResponses) GetResourcesWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error) {
	rsp, err := c.GetResources(ctx, resourcePoolId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcesResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, resourcePoolId, resourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetResourceTypesWithResponse request returning *GetResourceTypesResponse
func (c *ClientWithResponses) GetResourceTypesWithResponse(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*GetResourceTypesResponse, error) {
	rsp, err := c.GetResourceTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypesResponse(rsp)
}

// GetResourceTypeWithResponse request returning *GetResourceTypeResponse
func (c *ClientWithResponses) GetResourceTypeWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error) {
	rsp, err := c.GetResourceType(ctx, resourceTypeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypeResponse(rsp)
}

// GetSubscriptionsWithResponse request returning *GetSubscriptionsResponse
func (c *ClientWithResponses) GetSubscriptionsWithResponse(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error) {
	rsp, err := c.GetSubscriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionsResponse(rsp)
}

// CreateSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateSubscriptionResponse
func (c *ClientWithResponses) CreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) CreateSubscriptionWithResponse(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

// DeleteSubscriptionWithResponse request returning *DeleteSubscriptionResponse
func (c *ClientWithResponses) DeleteSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error) {
	rsp, err := c.DeleteSubscription(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionResponse(rsp)
}

// GetSubscriptionWithResponse request returning *GetSubscriptionResponse
func (c *ClientWithResponses) GetSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error) {
	rsp, err := c.GetSubscription(ctx, subscriptionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionResponse(rsp)
}

// ParseGetAllVersionsResponse parses an HTTP response from a GetAllVersionsWithResponse call
func ParseGetAllVersionsResponse(rsp *http.Response) (*GetAllVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.APIVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetCloudInfoResponse parses an HTTP response from a GetCloudInfoWithResponse call
func ParseGetCloudInfoResponse(rsp *http.Response) (*GetCloudInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OCloudInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetMinorVersionsResponse parses an HTTP response from a GetMinorVersionsWithResponse call
func ParseGetMinorVersionsResponse(rsp *http.Response) (*GetMinorVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMinorVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.APIVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDeploymentManagersResponse parses an HTTP response from a GetDeploymentManagersWithResponse call
func ParseGetDeploymentManagersResponse(rsp *http.Response) (*GetDeploymentManagersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentManagersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DeploymentManager
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDeploymentManagerResponse parses an HTTP response from a GetDeploymentManagerWithResponse call
func ParseGetDeploymentManagerResponse(rsp *http.Response) (*GetDeploymentManagerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentManagerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentManager
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcePoolsResponse parses an HTTP response from a GetResourcePoolsWithResponse call
func ParseGetResourcePoolsResponse(rsp *http.Response) (*GetResourcePoolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcePoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourcePool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcePoolResponse parses an HTTP response from a GetResourcePoolWithResponse call
func ParseGetResourcePoolResponse(rsp *http.Response) (*GetResourcePoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourcePool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcesResponse parses an HTTP response from a GetResourcesWithResponse call
func ParseGetResourcesResponse(rsp *http.Response) (*GetResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceTypesResponse parses an HTTP response from a GetResourceTypesWithResponse call
func ParseGetResourceTypesResponse(rsp *http.Response) (*GetResourceTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceTypeResponse parses an HTTP response from a GetResourceTypeWithResponse call
func ParseGetResourceTypeResponse(rsp *http.Response) (*GetResourceTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionsResponse parses an HTTP response from a GetSubscriptionsWithResponse call
func ParseGetSubscriptionsResponse(rsp *http.Response) (*GetSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSubscriptionResponse parses an HTTP response from a CreateSubscriptionWithResponse call
func ParseCreateSubscriptionResponse(rsp *http.Response) (*CreateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSubscriptionResponse parses an HTTP response from a DeleteSubscriptionWithResponse call
func ParseDeleteSubscriptionResponse(rsp *http.Response) (*DeleteSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionResponse parses an HTTP response from a GetSubscriptionWithResponse call
func ParseGetSubscriptionResponse(rsp *http.Response) (*GetSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"wxx/nHo7Ym46Mvo9/W8AAAD//4SDsjNLiwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../common/api/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
