// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
	externalRef0 "github.com/openshift-kni/oran-o2ims/internal/service/common/api/generated"
)

const (
	Oauth2Scopes = "oauth2.Scopes"
)

// Defines values for InventoryChangeNotificationNotificationEventType.
const (
	N0 InventoryChangeNotificationNotificationEventType = 0
	N1 InventoryChangeNotificationNotificationEventType = 1
	N2 InventoryChangeNotificationNotificationEventType = 2
)

// Defines values for ResourceTypeResourceClass.
const (
	ResourceTypeResourceClassCOMPUTE    ResourceTypeResourceClass = "COMPUTE"
	ResourceTypeResourceClassNETWORKING ResourceTypeResourceClass = "NETWORKING"
	ResourceTypeResourceClassSTORAGE    ResourceTypeResourceClass = "STORAGE"
	ResourceTypeResourceClassUNDEFINED  ResourceTypeResourceClass = "UNDEFINED"
)

// Defines values for ResourceTypeResourceKind.
const (
	ResourceTypeResourceKindLOGICAL   ResourceTypeResourceKind = "LOGICAL"
	ResourceTypeResourceKindPHYSICAL  ResourceTypeResourceKind = "PHYSICAL"
	ResourceTypeResourceKindUNDEFINED ResourceTypeResourceKind = "UNDEFINED"
)

// DeploymentManager Information about a deployment manager.
type DeploymentManager struct {
	// Capabilities Information about the capabilities supported by the Deployment Manager and its set of deployment management
	// services based on the resources allocated to the Deployment Manager.
	Capabilities map[string]string `json:"capabilities"`

	// Capacity Information about the available, allocated and reserved capacity of O-Cloud Resources allocated to the
	// Deployment Manager.
	Capacity map[string]string `json:"capacity"`

	// DeploymentManagerId Identifier for the Deployment Manager. This identifier is allocated by the O-Cloud.
	DeploymentManagerId openapi_types.UUID `json:"deploymentManagerId"`

	// Description Human readable description of the deployment manager
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related Deployment Manager.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// Name Human readable description of the deployment manager
	Name string `json:"name"`

	// OCloudId Identifier for the containing O-Cloud.
	OCloudId openapi_types.UUID `json:"oCloudId"`

	// ServiceUri The fully qualified URI to a Deployment Management server for O2dms services. Since the O2dms provides
	// multiple services, this entry is for the {apiRoot} only.
	ServiceUri string `json:"serviceUri"`

	// SupportedLocations List of globalLocationIDs that were assigned to the OCloud Site(s) which this Deployment Manager supports.
	SupportedLocations []string `json:"supportedLocations"`
}

// InventoryChangeNotification Information about an inventory change notification
type InventoryChangeNotification struct {
	// ConsumerSubscriptionId The value provided by the consumer in the subscription
	ConsumerSubscriptionId *openapi_types.UUID `json:"consumerSubscriptionId,omitempty"`

	// NotificationEventType One of the following values: 0 - create, 1 - modify, 2 - delete
	NotificationEventType InventoryChangeNotificationNotificationEventType `json:"notificationEventType"`

	// NotificationId A unique identifier to represent this notification event
	NotificationId openapi_types.UUID `json:"notificationId"`

	// ObjectRef The URL to the object. This is not required if the notificationEventType is 2 (DELETE). It will point to
	// one of the following data types defined in clause 3.2.6 and the reference will match the type of objects
	// supplied in priorObjectState and/or postObjectState.
	ObjectRef *string `json:"objectRef,omitempty"`

	// PostObjectState This is required if the notificationEventType is 0 (CREATE) or 1 (MODIFY) and is one of the following data
	// types defined in clause 3.2.6 and will match the type of object in priorObjectState and/or the type
	// referred to in objectRef.
	PostObjectState *map[string]interface{} `json:"postObjectState,omitempty"`

	// PriorObjectState This is required if the notificationEventType is 1 (MODIFY) or 2 (DELETE) and is one of the following
	// data types defined in clause 3.2.6 and will match the type of object in postObjectState and/or the type
	// referred to in objectRef.
	PriorObjectState *map[string]interface{} `json:"priorObjectState,omitempty"`
}

// InventoryChangeNotificationNotificationEventType One of the following values: 0 - create, 1 - modify, 2 - delete
type InventoryChangeNotificationNotificationEventType int

// OCloudInfo defines model for OCloudInfo.
type OCloudInfo struct {
	// Description Human readable description of the O-Cloud as provided by the SMO at cloud genesis.
	Description string                  `json:"description"`
	Extensions  *map[string]interface{} `json:"extensions,omitempty"`

	// GlobalcloudId Identifier of the O-Cloud instance assigned by the SMO. This identifier is globally unique across O-Cloud
	// instances known to the SMO. This value was provided by the SMO at cloud genesis and is stored in the O-Cloud
	// IMS Inventory.
	GlobalcloudId openapi_types.UUID `json:"globalcloudId"`

	// Name Human readable name of the O-Cloud as identified by the SMO at cloud genesis.
	Name string `json:"name"`

	// OCloudId Identifier of the O-Cloud instance. Internally generated within an O-Cloud instance.
	OCloudId openapi_types.UUID `json:"oCloudId"`

	// ServiceUri The URI root to all services provided by the O2ims interface. Inventory is one of these services.
	ServiceUri string `json:"serviceUri"`
}

// Resource Information about a resource.
type Resource struct {
	// Description Human readable description of the resource.
	Description string `json:"description"`

	// Elements The resource might be composed of smaller resources or other resource instances of a different type
	Elements []Resource `json:"elements"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource.
	Extensions map[string]interface{} `json:"extensions"`

	// GlobalAssetId Identifier or serial number of the resource, if available. It is required only if the resource has been
	// identified during its addition to the cloud as a reportable asset in the SMO inventory.
	GlobalAssetId string `json:"globalAssetId"`

	// Groups Keywords denoting groups a resource belongs to.
	Groups []string `json:"groups"`

	// ResourceId Identifier for the Resource. This identifier is allocated by the O-Cloud.
	ResourceId     openapi_types.UUID `json:"resourceId"`
	ResourcePoolId openapi_types.UUID `json:"resourcePoolId"`

	// ResourceTypeId Identifier for the Resource Type of this resource.
	ResourceTypeId openapi_types.UUID `json:"resourceTypeId"`

	// Tags Keywords describing or classifying the resource instance
	Tags []string `json:"tags"`
}

// ResourcePool Information about a resource pool.
type ResourcePool struct {
	// Description Human readable description of the resource pool.
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource pool.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// GlobalLocationId This identifier is copied from the O-Cloud Id assigned by the SMO during the O-Cloud deployment
	GlobalLocationId openapi_types.UUID `json:"globalLocationId"`

	// Location Information about the geographical location of the resource pool as detected by the O-Cloud.
	Location *string `json:"location,omitempty"`

	// Name Human readable name of the resource pool.
	Name string `json:"name"`

	// OCloudId Identifier for the containing O-Cloud.
	OCloudId openapi_types.UUID `json:"oCloudId"`

	// ResourcePoolId Identifier for the Resource Pool in the O-Cloud instance. This identifier is allocated by the O-Cloud.
	ResourcePoolId openapi_types.UUID `json:"resourcePoolId"`
}

// ResourceType Information about a resource type.
type ResourceType struct {
	// AlarmDictionary Information about an alarm dictionary.
	AlarmDictionary *externalRef0.AlarmDictionary `json:"alarmDictionary,omitempty"`

	// Description Human readable description of the resource type.
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource type.
	Extensions map[string]interface{} `json:"extensions"`

	// Model Information about the model of the resource as defined by its provider.
	Model string `json:"model"`

	// Name Human readable name of the resource type.
	Name string `json:"name"`

	// ResourceClass Functional role of the resource type within the cloud.
	ResourceClass ResourceTypeResourceClass `json:"resourceClass"`

	// ResourceKind Value describing “physicality” of the resource type.
	ResourceKind ResourceTypeResourceKind `json:"resourceKind"`

	// ResourceTypeId Identifier for the Resource Type. This identifier is allocated by the O-Cloud.
	ResourceTypeId openapi_types.UUID `json:"resourceTypeId"`

	// Vendor Provider of the Resource.
	Vendor string `json:"vendor"`

	// Version Version or generation of the resource as defined by its provider.
	Version string `json:"version"`
}

// ResourceTypeResourceClass Functional role of the resource type within the cloud.
type ResourceTypeResourceClass string

// ResourceTypeResourceKind Value describing “physicality” of the resource type.
type ResourceTypeResourceKind string

// Subscription Information about an inventory subscription.
type Subscription struct {
	// Callback The fully qualified URI to a consumer procedure which can process a Post of the
	// InventoryEventNotification.
	Callback string `json:"callback"`

	// ConsumerSubscriptionId Identifier for the consumer of events sent due to the Subscription.
	ConsumerSubscriptionId *openapi_types.UUID `json:"consumerSubscriptionId,omitempty"`

	// Filter Criteria for events which do not need to be reported or will be filtered by the subscription
	// notification service. Therefore, if a filter is not provided then all events are reported.
	Filter *string `json:"filter,omitempty"`

	// SubscriptionId Identifier for the Subscription. This identifier is allocated by the O-Cloud.
	SubscriptionId *openapi_types.UUID `json:"subscriptionId,omitempty"`
}

// DeploymentManagerId defines model for deploymentManagerId.
type DeploymentManagerId = openapi_types.UUID

// ResourceId defines model for resourceId.
type ResourceId = openapi_types.UUID

// ResourcePoolId defines model for resourcePoolId.
type ResourcePoolId = openapi_types.UUID

// ResourceTypeId defines model for resourceTypeId.
type ResourceTypeId = openapi_types.UUID

// SubscriptionId defines model for subscriptionId.
type SubscriptionId = openapi_types.UUID

// GetCloudInfoParams defines parameters for GetCloudInfo.
type GetCloudInfoParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetAlarmDictionariesParams defines parameters for GetAlarmDictionaries.
type GetAlarmDictionariesParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetDeploymentManagersParams defines parameters for GetDeploymentManagers.
type GetDeploymentManagersParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetResourcePoolsParams defines parameters for GetResourcePools.
type GetResourcePoolsParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetResourcesParams defines parameters for GetResources.
type GetResourcesParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetResourceTypesParams defines parameters for GetResourceTypes.
type GetResourceTypesParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetSubscriptionsParams defines parameters for GetSubscriptions.
type GetSubscriptionsParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// CreateSubscriptionJSONRequestBody defines body for CreateSubscription for application/json ContentType.
type CreateSubscriptionJSONRequestBody = Subscription

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllVersions request
	GetAllVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudInfo request
	GetCloudInfo(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlarmDictionaries request
	GetAlarmDictionaries(ctx context.Context, params *GetAlarmDictionariesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlarmDictionary request
	GetAlarmDictionary(ctx context.Context, alarmDictionaryId externalRef0.AlarmDictionaryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMinorVersions request
	GetMinorVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentManagers request
	GetDeploymentManagers(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentManager request
	GetDeploymentManager(ctx context.Context, deploymentManagerId DeploymentManagerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInternalResourceById request
	GetInternalResourceById(ctx context.Context, resourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcePools request
	GetResourcePools(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcePool request
	GetResourcePool(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResources request
	GetResources(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceTypes request
	GetResourceTypes(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceType request
	GetResourceType(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceTypeAlarmDictionary request
	GetResourceTypeAlarmDictionary(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptions request
	GetSubscriptions(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubscriptionWithBody request with any body
	CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubscription(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscription request
	DeleteSubscription(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscription request
	GetSubscription(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudInfo(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlarmDictionaries(ctx context.Context, params *GetAlarmDictionariesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlarmDictionariesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlarmDictionary(ctx context.Context, alarmDictionaryId externalRef0.AlarmDictionaryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlarmDictionaryRequest(c.Server, alarmDictionaryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMinorVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMinorVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentManagers(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentManagersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentManager(ctx context.Context, deploymentManagerId DeploymentManagerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentManagerRequest(c.Server, deploymentManagerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInternalResourceById(ctx context.Context, resourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInternalResourceByIdRequest(c.Server, resourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcePools(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcePoolsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcePool(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcePoolRequest(c.Server, resourcePoolId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResources(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcesRequest(c.Server, resourcePoolId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, resourcePoolId, resourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceTypes(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceType(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypeRequest(c.Server, resourceTypeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceTypeAlarmDictionary(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypeAlarmDictionaryRequest(c.Server, resourceTypeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptions(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscription(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscription(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscription(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllVersionsRequest generates requests for GetAllVersions
func NewGetAllVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/api_versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCloudInfoRequest generates requests for GetCloudInfo
func NewGetCloudInfoRequest(server string, params *GetCloudInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAlarmDictionariesRequest generates requests for GetAlarmDictionaries
func NewGetAlarmDictionariesRequest(server string, params *GetAlarmDictionariesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/alarmDictionaries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAlarmDictionaryRequest generates requests for GetAlarmDictionary
func NewGetAlarmDictionaryRequest(server string, alarmDictionaryId externalRef0.AlarmDictionaryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alarmDictionaryId", runtime.ParamLocationPath, alarmDictionaryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/alarmDictionaries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMinorVersionsRequest generates requests for GetMinorVersions
func NewGetMinorVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/api_versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentManagersRequest generates requests for GetDeploymentManagers
func NewGetDeploymentManagersRequest(server string, params *GetDeploymentManagersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/deploymentManagers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentManagerRequest generates requests for GetDeploymentManager
func NewGetDeploymentManagerRequest(server string, deploymentManagerId DeploymentManagerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deploymentManagerId", runtime.ParamLocationPath, deploymentManagerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/deploymentManagers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInternalResourceByIdRequest generates requests for GetInternalResourceById
func NewGetInternalResourceByIdRequest(server string, resourceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/internal/resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcePoolsRequest generates requests for GetResourcePools
func NewGetResourcePoolsRequest(server string, params *GetResourcePoolsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcePoolRequest generates requests for GetResourcePool
func NewGetResourcePoolRequest(server string, resourcePoolId ResourcePoolId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcesRequest generates requests for GetResources
func NewGetResourcesRequest(server string, resourcePoolId ResourcePoolId, params *GetResourcesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s/resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, resourcePoolId ResourcePoolId, resourceId ResourceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s/resources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypesRequest generates requests for GetResourceTypes
func NewGetResourceTypesRequest(server string, params *GetResourceTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourceTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypeRequest generates requests for GetResourceType
func NewGetResourceTypeRequest(server string, resourceTypeId ResourceTypeId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceTypeId", runtime.ParamLocationPath, resourceTypeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourceTypes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypeAlarmDictionaryRequest generates requests for GetResourceTypeAlarmDictionary
func NewGetResourceTypeAlarmDictionaryRequest(server string, resourceTypeId ResourceTypeId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceTypeId", runtime.ParamLocationPath, resourceTypeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourceTypes/%s/alarmDictionary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionsRequest generates requests for GetSubscriptions
func NewGetSubscriptionsRequest(server string, params *GetSubscriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubscriptionRequest calls the generic CreateSubscription builder with application/json body
func NewCreateSubscriptionRequest(server string, body CreateSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubscriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSubscriptionRequestWithBody generates requests for CreateSubscription with any type of body
func NewCreateSubscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscriptionRequest generates requests for DeleteSubscription
func NewDeleteSubscriptionRequest(server string, subscriptionId SubscriptionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionRequest generates requests for GetSubscription
func NewGetSubscriptionRequest(server string, subscriptionId SubscriptionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllVersionsWithResponse request
	GetAllVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVersionsResponse, error)

	// GetCloudInfoWithResponse request
	GetCloudInfoWithResponse(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*GetCloudInfoResponse, error)

	// GetAlarmDictionariesWithResponse request
	GetAlarmDictionariesWithResponse(ctx context.Context, params *GetAlarmDictionariesParams, reqEditors ...RequestEditorFn) (*GetAlarmDictionariesResponse, error)

	// GetAlarmDictionaryWithResponse request
	GetAlarmDictionaryWithResponse(ctx context.Context, alarmDictionaryId externalRef0.AlarmDictionaryId, reqEditors ...RequestEditorFn) (*GetAlarmDictionaryResponse, error)

	// GetMinorVersionsWithResponse request
	GetMinorVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMinorVersionsResponse, error)

	// GetDeploymentManagersWithResponse request
	GetDeploymentManagersWithResponse(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagersResponse, error)

	// GetDeploymentManagerWithResponse request
	GetDeploymentManagerWithResponse(ctx context.Context, deploymentManagerId DeploymentManagerId, reqEditors ...RequestEditorFn) (*GetDeploymentManagerResponse, error)

	// GetInternalResourceByIdWithResponse request
	GetInternalResourceByIdWithResponse(ctx context.Context, resourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInternalResourceByIdResponse, error)

	// GetResourcePoolsWithResponse request
	GetResourcePoolsWithResponse(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*GetResourcePoolsResponse, error)

	// GetResourcePoolWithResponse request
	GetResourcePoolWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*GetResourcePoolResponse, error)

	// GetResourcesWithResponse request
	GetResourcesWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetResourceTypesWithResponse request
	GetResourceTypesWithResponse(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*GetResourceTypesResponse, error)

	// GetResourceTypeWithResponse request
	GetResourceTypeWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error)

	// GetResourceTypeAlarmDictionaryWithResponse request
	GetResourceTypeAlarmDictionaryWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeAlarmDictionaryResponse, error)

	// GetSubscriptionsWithResponse request
	GetSubscriptionsWithResponse(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error)

	// CreateSubscriptionWithBodyWithResponse request with any body
	CreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	CreateSubscriptionWithResponse(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	// DeleteSubscriptionWithResponse request
	DeleteSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error)

	// GetSubscriptionWithResponse request
	GetSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error)
}

type GetAllVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.APIVersions
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAllVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudInfoResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OCloudInfo
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetCloudInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlarmDictionariesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]externalRef0.AlarmDictionary
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAlarmDictionariesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlarmDictionariesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlarmDictionaryResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.AlarmDictionary
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAlarmDictionaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlarmDictionaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMinorVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.APIVersions
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetMinorVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMinorVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentManagersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]DeploymentManager
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDeploymentManagersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentManagersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentManagerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DeploymentManager
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDeploymentManagerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentManagerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInternalResourceByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Resource
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetInternalResourceByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInternalResourceByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcePoolsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]ResourcePool
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcePoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcePoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcePoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResourcePool
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]Resource
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Resource
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]ResourceType
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResourceType
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypeAlarmDictionaryResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.AlarmDictionary
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceTypeAlarmDictionaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypeAlarmDictionaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]Subscription
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *Subscription
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Subscription
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllVersionsWithResponse request returning *GetAllVersionsResponse
func (c *ClientWithResponses) GetAllVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVersionsResponse, error) {
	rsp, err := c.GetAllVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllVersionsResponse(rsp)
}

// GetCloudInfoWithResponse request returning *GetCloudInfoResponse
func (c *ClientWithResponses) GetCloudInfoWithResponse(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*GetCloudInfoResponse, error) {
	rsp, err := c.GetCloudInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudInfoResponse(rsp)
}

// GetAlarmDictionariesWithResponse request returning *GetAlarmDictionariesResponse
func (c *ClientWithResponses) GetAlarmDictionariesWithResponse(ctx context.Context, params *GetAlarmDictionariesParams, reqEditors ...RequestEditorFn) (*GetAlarmDictionariesResponse, error) {
	rsp, err := c.GetAlarmDictionaries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlarmDictionariesResponse(rsp)
}

// GetAlarmDictionaryWithResponse request returning *GetAlarmDictionaryResponse
func (c *ClientWithResponses) GetAlarmDictionaryWithResponse(ctx context.Context, alarmDictionaryId externalRef0.AlarmDictionaryId, reqEditors ...RequestEditorFn) (*GetAlarmDictionaryResponse, error) {
	rsp, err := c.GetAlarmDictionary(ctx, alarmDictionaryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlarmDictionaryResponse(rsp)
}

// GetMinorVersionsWithResponse request returning *GetMinorVersionsResponse
func (c *ClientWithResponses) GetMinorVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMinorVersionsResponse, error) {
	rsp, err := c.GetMinorVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMinorVersionsResponse(rsp)
}

// GetDeploymentManagersWithResponse request returning *GetDeploymentManagersResponse
func (c *ClientWithResponses) GetDeploymentManagersWithResponse(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagersResponse, error) {
	rsp, err := c.GetDeploymentManagers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentManagersResponse(rsp)
}

// GetDeploymentManagerWithResponse request returning *GetDeploymentManagerResponse
func (c *ClientWithResponses) GetDeploymentManagerWithResponse(ctx context.Context, deploymentManagerId DeploymentManagerId, reqEditors ...RequestEditorFn) (*GetDeploymentManagerResponse, error) {
	rsp, err := c.GetDeploymentManager(ctx, deploymentManagerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentManagerResponse(rsp)
}

// GetInternalResourceByIdWithResponse request returning *GetInternalResourceByIdResponse
func (c *ClientWithResponses) GetInternalResourceByIdWithResponse(ctx context.Context, resourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInternalResourceByIdResponse, error) {
	rsp, err := c.GetInternalResourceById(ctx, resourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInternalResourceByIdResponse(rsp)
}

// GetResourcePoolsWithResponse request returning *GetResourcePoolsResponse
func (c *ClientWithResponses) GetResourcePoolsWithResponse(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*GetResourcePoolsResponse, error) {
	rsp, err := c.GetResourcePools(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcePoolsResponse(rsp)
}

// GetResourcePoolWithResponse request returning *GetResourcePoolResponse
func (c *ClientWithResponses) GetResourcePoolWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*GetResourcePoolResponse, error) {
	rsp, err := c.GetResourcePool(ctx, resourcePoolId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcePoolResponse(rsp)
}

// GetResourcesWithResponse request returning *GetResourcesResponse
func (c *ClientWithResponses) GetResourcesWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error) {
	rsp, err := c.GetResources(ctx, resourcePoolId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcesResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, resourcePoolId, resourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetResourceTypesWithResponse request returning *GetResourceTypesResponse
func (c *ClientWithResponses) GetResourceTypesWithResponse(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*GetResourceTypesResponse, error) {
	rsp, err := c.GetResourceTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypesResponse(rsp)
}

// GetResourceTypeWithResponse request returning *GetResourceTypeResponse
func (c *ClientWithResponses) GetResourceTypeWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error) {
	rsp, err := c.GetResourceType(ctx, resourceTypeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypeResponse(rsp)
}

// GetResourceTypeAlarmDictionaryWithResponse request returning *GetResourceTypeAlarmDictionaryResponse
func (c *ClientWithResponses) GetResourceTypeAlarmDictionaryWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeAlarmDictionaryResponse, error) {
	rsp, err := c.GetResourceTypeAlarmDictionary(ctx, resourceTypeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypeAlarmDictionaryResponse(rsp)
}

// GetSubscriptionsWithResponse request returning *GetSubscriptionsResponse
func (c *ClientWithResponses) GetSubscriptionsWithResponse(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error) {
	rsp, err := c.GetSubscriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionsResponse(rsp)
}

// CreateSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateSubscriptionResponse
func (c *ClientWithResponses) CreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) CreateSubscriptionWithResponse(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

// DeleteSubscriptionWithResponse request returning *DeleteSubscriptionResponse
func (c *ClientWithResponses) DeleteSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error) {
	rsp, err := c.DeleteSubscription(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionResponse(rsp)
}

// GetSubscriptionWithResponse request returning *GetSubscriptionResponse
func (c *ClientWithResponses) GetSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error) {
	rsp, err := c.GetSubscription(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionResponse(rsp)
}

// ParseGetAllVersionsResponse parses an HTTP response from a GetAllVersionsWithResponse call
func ParseGetAllVersionsResponse(rsp *http.Response) (*GetAllVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.APIVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetCloudInfoResponse parses an HTTP response from a GetCloudInfoWithResponse call
func ParseGetCloudInfoResponse(rsp *http.Response) (*GetCloudInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OCloudInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAlarmDictionariesResponse parses an HTTP response from a GetAlarmDictionariesWithResponse call
func ParseGetAlarmDictionariesResponse(rsp *http.Response) (*GetAlarmDictionariesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlarmDictionariesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []externalRef0.AlarmDictionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAlarmDictionaryResponse parses an HTTP response from a GetAlarmDictionaryWithResponse call
func ParseGetAlarmDictionaryResponse(rsp *http.Response) (*GetAlarmDictionaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlarmDictionaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.AlarmDictionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetMinorVersionsResponse parses an HTTP response from a GetMinorVersionsWithResponse call
func ParseGetMinorVersionsResponse(rsp *http.Response) (*GetMinorVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMinorVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.APIVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDeploymentManagersResponse parses an HTTP response from a GetDeploymentManagersWithResponse call
func ParseGetDeploymentManagersResponse(rsp *http.Response) (*GetDeploymentManagersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentManagersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DeploymentManager
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDeploymentManagerResponse parses an HTTP response from a GetDeploymentManagerWithResponse call
func ParseGetDeploymentManagerResponse(rsp *http.Response) (*GetDeploymentManagerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentManagerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentManager
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetInternalResourceByIdResponse parses an HTTP response from a GetInternalResourceByIdWithResponse call
func ParseGetInternalResourceByIdResponse(rsp *http.Response) (*GetInternalResourceByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInternalResourceByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcePoolsResponse parses an HTTP response from a GetResourcePoolsWithResponse call
func ParseGetResourcePoolsResponse(rsp *http.Response) (*GetResourcePoolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcePoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourcePool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcePoolResponse parses an HTTP response from a GetResourcePoolWithResponse call
func ParseGetResourcePoolResponse(rsp *http.Response) (*GetResourcePoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourcePool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcesResponse parses an HTTP response from a GetResourcesWithResponse call
func ParseGetResourcesResponse(rsp *http.Response) (*GetResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceTypesResponse parses an HTTP response from a GetResourceTypesWithResponse call
func ParseGetResourceTypesResponse(rsp *http.Response) (*GetResourceTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceTypeResponse parses an HTTP response from a GetResourceTypeWithResponse call
func ParseGetResourceTypeResponse(rsp *http.Response) (*GetResourceTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceTypeAlarmDictionaryResponse parses an HTTP response from a GetResourceTypeAlarmDictionaryWithResponse call
func ParseGetResourceTypeAlarmDictionaryResponse(rsp *http.Response) (*GetResourceTypeAlarmDictionaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypeAlarmDictionaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.AlarmDictionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionsResponse parses an HTTP response from a GetSubscriptionsWithResponse call
func ParseGetSubscriptionsResponse(rsp *http.Response) (*GetSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSubscriptionResponse parses an HTTP response from a CreateSubscriptionWithResponse call
func ParseCreateSubscriptionResponse(rsp *http.Response) (*CreateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSubscriptionResponse parses an HTTP response from a DeleteSubscriptionWithResponse call
func ParseDeleteSubscriptionResponse(rsp *http.Response) (*DeleteSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionResponse parses an HTTP response from a GetSubscriptionWithResponse call
func ParseGetSubscriptionResponse(rsp *http.Response) (*GetSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"kRENK7gAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../common/api/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
