// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
	externalRef0 "github.com/openshift-kni/oran-o2ims/internal/service/common/api/generated"
)

const (
	Oauth2Scopes = "oauth2.Scopes"
)

// Defines values for InventoryChangeNotificationNotificationEventType.
const (
	N0 InventoryChangeNotificationNotificationEventType = 0
	N1 InventoryChangeNotificationNotificationEventType = 1
	N2 InventoryChangeNotificationNotificationEventType = 2
)

// Defines values for LocationInfoCoordinateType.
const (
	Point LocationInfoCoordinateType = "Point"
)

// Defines values for ResourceTypeResourceClass.
const (
	ResourceTypeResourceClassCOMPUTE    ResourceTypeResourceClass = "COMPUTE"
	ResourceTypeResourceClassNETWORKING ResourceTypeResourceClass = "NETWORKING"
	ResourceTypeResourceClassSTORAGE    ResourceTypeResourceClass = "STORAGE"
	ResourceTypeResourceClassUNDEFINED  ResourceTypeResourceClass = "UNDEFINED"
)

// Defines values for ResourceTypeResourceKind.
const (
	ResourceTypeResourceKindLOGICAL   ResourceTypeResourceKind = "LOGICAL"
	ResourceTypeResourceKindPHYSICAL  ResourceTypeResourceKind = "PHYSICAL"
	ResourceTypeResourceKindUNDEFINED ResourceTypeResourceKind = "UNDEFINED"
)

// DeploymentManager Information about a deployment manager.
type DeploymentManager struct {
	// Capabilities Information about the capabilities supported by the Deployment Manager and its set of deployment management
	// services based on the resources allocated to the Deployment Manager.
	Capabilities map[string]string `json:"capabilities"`

	// Capacity Information about the available, allocated and reserved capacity of O-Cloud Resources allocated to the
	// Deployment Manager.
	Capacity map[string]string `json:"capacity"`

	// DeploymentManagerId Identifier for the Deployment Manager. This identifier is allocated by the O-Cloud.
	DeploymentManagerId openapi_types.UUID `json:"deploymentManagerId"`

	// Description Human readable description of the deployment manager
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related Deployment Manager.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// Name Human readable description of the deployment manager
	Name string `json:"name"`

	// OCloudId Identifier for the containing O-Cloud.
	OCloudId openapi_types.UUID `json:"oCloudId"`

	// ServiceUri The fully qualified URI to a Deployment Management server for O2dms services. Since the O2dms provides
	// multiple services, this entry is for the {apiRoot} only.
	ServiceUri string `json:"serviceUri"`

	// SupportedLocations List of globalLocationIDs that were assigned to the OCloud Site(s) which this Deployment Manager supports.
	SupportedLocations []string `json:"supportedLocations"`
}

// InventoryChangeNotification Information about an inventory change notification
type InventoryChangeNotification struct {
	// ConsumerSubscriptionId The value provided by the consumer in the subscription
	ConsumerSubscriptionId *openapi_types.UUID `json:"consumerSubscriptionId,omitempty"`

	// NotificationEventType One of the following values: 0 - create, 1 - modify, 2 - delete
	NotificationEventType InventoryChangeNotificationNotificationEventType `json:"notificationEventType"`

	// NotificationId A unique identifier to represent this notification event
	NotificationId openapi_types.UUID `json:"notificationId"`

	// ObjectRef The URL to the object. This is not required if the notificationEventType is 2 (DELETE). It will point to
	// one of the following data types defined in clause 3.2.6 and the reference will match the type of objects
	// supplied in priorObjectState and/or postObjectState.
	ObjectRef *string `json:"objectRef,omitempty"`

	// PostObjectState This is required if the notificationEventType is 0 (CREATE) or 1 (MODIFY) and is one of the following data
	// types defined in clause 3.2.6 and will match the type of object in priorObjectState and/or the type
	// referred to in objectRef.
	PostObjectState *map[string]interface{} `json:"postObjectState,omitempty"`

	// PriorObjectState This is required if the notificationEventType is 1 (MODIFY) or 2 (DELETE) and is one of the following
	// data types defined in clause 3.2.6 and will match the type of object in postObjectState and/or the type
	// referred to in objectRef.
	PriorObjectState *map[string]interface{} `json:"priorObjectState,omitempty"`
}

// InventoryChangeNotificationNotificationEventType One of the following values: 0 - create, 1 - modify, 2 - delete
type InventoryChangeNotificationNotificationEventType int

// LocationInfo Information about a location where O-Cloud Sites can be available.
//
// NOTE: Per O-RAN.WG6.TS.O2IMS-INTERFACE-R005-v11.00 3.2.6.2.16, at least one of 'coordinate',
// 'civicAddress', or 'address' shall be provided when creating location data.
type LocationInfo struct {
	// Address Human readable format of address of the location.
	Address *string `json:"address,omitempty"`

	// CivicAddress Civic address of the location. Includes zero or more elements comprising the civic address.
	// The caType values follow IETF RFC 4776 civic address format:
	//   - caType 1: Country (ISO 3166-1 alpha-2 code)
	//   - caType 3: State, province, or autonomous community
	//   - caType 6: City or municipality
	//   - caType 22: Street name
	//   - caType 26: Street number or building number
	CivicAddress *[]struct {
		// CaType Describes the content type of caValue. The value of caType shall comply with IETF RFC 4776.
		CaType int `json:"caType"`

		// CaValue Content of civic address element corresponding to the caType.
		CaValue string `json:"caValue"`
	} `json:"civicAddress,omitempty"`

	// Coordinate The coordinates (including latitude and longitude) of the location. The content of this attribute
	// follows the provisions for the "Point" geometry object as defined in IETF RFC 7946.
	Coordinate *struct {
		// Coordinates Longitude and latitude coordinates [longitude, latitude]
		Coordinates *[]float32 `json:"coordinates,omitempty"`

		// Type GeoJSON geometry type
		Type *LocationInfoCoordinateType `json:"type,omitempty"`
	} `json:"coordinate,omitempty"`

	// Description Human readable description of the location.
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related location.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// GlobalLocationId Identifier of the location as defined by the SMO.
	GlobalLocationId string `json:"globalLocationId"`

	// Name Human readable name of the location as defined by the SMO.
	Name string `json:"name"`

	// OCloudSiteIds List of O-Cloud Site identifiers referencing the O-Cloud Sites available at the location.
	OCloudSiteIds *[]openapi_types.UUID `json:"oCloudSiteIds,omitempty"`
}

// LocationInfoCoordinateType GeoJSON geometry type
type LocationInfoCoordinateType string

// OCloudInfo defines model for OCloudInfo.
type OCloudInfo struct {
	// Description Human readable description of the O-Cloud as provided by the SMO at cloud genesis.
	Description string `json:"description"`

	// Extensions These are unspecified (not standardized) properties (keys) which are tailored by the vendor to extend the
	// information provided about the O-Cloud.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// GlobalCloudId Identifier of the O-Cloud instance assigned by the SMO. This identifier is globally unique across O-Cloud
	// instances known to the SMO. This value was provided by the SMO with the callback URI at the beginning of
	// O-Cloud genesis and used in registration at the end of genesis.
	GlobalCloudId openapi_types.UUID `json:"globalCloudId"`

	// Name Human readable name of the O-Cloud as identified by the SMO at cloud genesis.
	Name string `json:"name"`

	// OCloudId Identifier of the O-Cloud instance. Internally generated within an O-Cloud instance.
	OCloudId openapi_types.UUID `json:"oCloudId"`

	// ServiceUri The fully qualified URI root to all services provided by the O2ims interface, Inventory only being one of
	// them. Since the O2ims provides multiple services this entry is for the {apiRoot} only.
	ServiceUri string `json:"serviceUri"`
}

// OCloudSiteInfo Information about an O-Cloud site instance.
type OCloudSiteInfo struct {
	// Description Human readable description of the O-Cloud site as provided by the cloud provider.
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related O-Cloud site.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// GlobalLocationId Identifier of location where the O-Cloud site is deployed at.
	GlobalLocationId string `json:"globalLocationId"`

	// Name Human readable name of the O-Cloud site as identified by the cloud provider.
	Name string `json:"name"`

	// OCloudSiteId Identifier of the O-Cloud site. Locally unique within the scope of an O-Cloud instance.
	OCloudSiteId openapi_types.UUID `json:"oCloudSiteId"`

	// ResourcePools List of resource pools that are part of the O-Cloud site.
	ResourcePools []openapi_types.UUID `json:"resourcePools"`
}

// Resource Information about a resource.
type Resource struct {
	// Description Human readable description of the resource.
	Description string `json:"description"`

	// Elements The resource might be composed of smaller resources or other resource instances of a different type
	Elements []Resource `json:"elements"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource.
	Extensions map[string]interface{} `json:"extensions"`

	// GlobalAssetId Identifier or serial number of the resource, if available. It is required only if the resource has been
	// identified during its addition to the cloud as a reportable asset in the SMO inventory.
	GlobalAssetId string `json:"globalAssetId"`

	// Groups Keywords denoting groups a resource belongs to.
	Groups []string `json:"groups"`

	// ResourceId Identifier for the Resource. This identifier is allocated by the O-Cloud.
	ResourceId     openapi_types.UUID `json:"resourceId"`
	ResourcePoolId openapi_types.UUID `json:"resourcePoolId"`

	// ResourceTypeId Identifier for the Resource Type of this resource.
	ResourceTypeId openapi_types.UUID `json:"resourceTypeId"`

	// Tags Keywords describing or classifying the resource instance
	Tags []string `json:"tags"`
}

// ResourcePool Information about a resource pool.
type ResourcePool struct {
	// Description Human readable description of the resource pool.
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource pool.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// GlobalLocationId This identifier is copied from the O-Cloud Id assigned by the SMO during the O-Cloud deployment.
	//
	// DEPRECATED (since v2.0.0): replaced by structured LocationInfo model.
	//
	// See migration guide: docs/deprecations/resource-pool-fields.md
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	GlobalLocationId openapi_types.UUID `json:"globalLocationId"`

	// Location Information about the geographical location of the resource pool as detected by the O-Cloud.
	//
	// DEPRECATED (since v2.0.0): simple string replaced with rich LocationInfo structure
	// supporting coordinates, civic addresses and human-readable addresses.
	//
	// See migration guide: docs/deprecations/resource-pool-fields.md
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Location *string `json:"location,omitempty"`

	// Name Human readable name of the resource pool.
	Name string `json:"name"`

	// OCloudId Identifier for the containing O-Cloud.
	//
	// DEPRECATED (since v2.0.0): redundant, O-Cloud context is implicit in the API path.
	//
	// See migration guide: docs/deprecations/resource-pool-fields.md
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OCloudId openapi_types.UUID `json:"oCloudId"`

	// OCloudSiteId Identifier of the O-Cloud site the resource pool is a part of.
	OCloudSiteId openapi_types.UUID `json:"oCloudSiteId"`

	// ResourcePoolId Identifier for the Resource Pool in the O-Cloud instance. This identifier is allocated by the O-Cloud.
	ResourcePoolId openapi_types.UUID `json:"resourcePoolId"`
}

// ResourceType Information about a resource type.
type ResourceType struct {
	// AlarmDictionary Dictionary of alarms for this resource type.
	//
	// DEPRECATED (since v2.0.0): full embedded object replaced with ID reference for efficiency.
	//
	// See migration guide: docs/deprecations/alarm-dictionary.md
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	AlarmDictionary *externalRef0.AlarmDictionary `json:"alarmDictionary,omitempty"`

	// AlarmDictionaryId Identifier of the Alarm Dictionary for this resource type. The IMS shall ensure that the identifier points
	// to the same dictionary available under the URI path of the resource type.
	AlarmDictionaryId *openapi_types.UUID `json:"alarmDictionaryId,omitempty"`

	// Description Human readable description of the resource type.
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource type.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// Model Information about the model of the resource as defined by its provider.
	Model string `json:"model"`

	// Name Human readable name of the resource type.
	Name string `json:"name"`

	// ResourceClass Functional role of the resource type within the cloud.
	ResourceClass ResourceTypeResourceClass `json:"resourceClass"`

	// ResourceKind Value describing "physicality" of the resource type.
	ResourceKind ResourceTypeResourceKind `json:"resourceKind"`

	// ResourceTypeId Identifier for the Resource Type. This identifier is allocated by the O-Cloud.
	ResourceTypeId openapi_types.UUID `json:"resourceTypeId"`

	// Vendor Provider of the Resource.
	Vendor string `json:"vendor"`

	// Version Version or generation of the resource as defined by its provider.
	Version string `json:"version"`
}

// ResourceTypeResourceClass Functional role of the resource type within the cloud.
type ResourceTypeResourceClass string

// ResourceTypeResourceKind Value describing "physicality" of the resource type.
type ResourceTypeResourceKind string

// Subscription Information about an inventory subscription.
type Subscription struct {
	// Callback The fully qualified URI to a consumer procedure which can process a Post of the
	// InventoryEventNotification.
	Callback string `json:"callback"`

	// ConsumerSubscriptionId Identifier for the consumer of events sent due to the Subscription.
	ConsumerSubscriptionId *openapi_types.UUID `json:"consumerSubscriptionId,omitempty"`

	// Filter Criteria for events which do not need to be reported or will be filtered by the subscription
	// notification service. Therefore, if a filter is not provided then all events are reported.
	Filter *string `json:"filter,omitempty"`

	// SubscriptionId Identifier for the Subscription. This identifier is allocated by the O-Cloud.
	SubscriptionId *openapi_types.UUID `json:"subscriptionId,omitempty"`
}

// DeploymentManagerId defines model for deploymentManagerId.
type DeploymentManagerId = openapi_types.UUID

// GlobalLocationId defines model for globalLocationId.
type GlobalLocationId = string

// OCloudSiteId defines model for oCloudSiteId.
type OCloudSiteId = openapi_types.UUID

// ResourceId defines model for resourceId.
type ResourceId = openapi_types.UUID

// ResourcePoolId defines model for resourcePoolId.
type ResourcePoolId = openapi_types.UUID

// ResourceTypeId defines model for resourceTypeId.
type ResourceTypeId = openapi_types.UUID

// SubscriptionId defines model for subscriptionId.
type SubscriptionId = openapi_types.UUID

// GetCloudInfoParams defines parameters for GetCloudInfo.
type GetCloudInfoParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetAlarmDictionariesParams defines parameters for GetAlarmDictionaries.
type GetAlarmDictionariesParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetDeploymentManagersParams defines parameters for GetDeploymentManagers.
type GetDeploymentManagersParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetLocationsParams defines parameters for GetLocations.
type GetLocationsParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetOCloudSitesParams defines parameters for GetOCloudSites.
type GetOCloudSitesParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetResourcePoolsParams defines parameters for GetResourcePools.
type GetResourcePoolsParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetResourcesParams defines parameters for GetResources.
type GetResourcesParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetResourceTypesParams defines parameters for GetResourceTypes.
type GetResourceTypesParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetSubscriptionsParams defines parameters for GetSubscriptions.
type GetSubscriptionsParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// CreateSubscriptionJSONRequestBody defines body for CreateSubscription for application/json ContentType.
type CreateSubscriptionJSONRequestBody = Subscription

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllVersions request
	GetAllVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudInfo request
	GetCloudInfo(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlarmDictionaries request
	GetAlarmDictionaries(ctx context.Context, params *GetAlarmDictionariesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlarmDictionary request
	GetAlarmDictionary(ctx context.Context, alarmDictionaryId externalRef0.AlarmDictionaryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMinorVersions request
	GetMinorVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentManagers request
	GetDeploymentManagers(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentManager request
	GetDeploymentManager(ctx context.Context, deploymentManagerId DeploymentManagerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInternalResourceById request
	GetInternalResourceById(ctx context.Context, resourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocations request
	GetLocations(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocation request
	GetLocation(ctx context.Context, globalLocationId GlobalLocationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOCloudSites request
	GetOCloudSites(ctx context.Context, params *GetOCloudSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOCloudSite request
	GetOCloudSite(ctx context.Context, oCloudSiteId OCloudSiteId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcePools request
	GetResourcePools(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcePool request
	GetResourcePool(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResources request
	GetResources(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceTypes request
	GetResourceTypes(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceType request
	GetResourceType(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceTypeAlarmDictionary request
	GetResourceTypeAlarmDictionary(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptions request
	GetSubscriptions(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubscriptionWithBody request with any body
	CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubscription(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscription request
	DeleteSubscription(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscription request
	GetSubscription(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudInfo(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlarmDictionaries(ctx context.Context, params *GetAlarmDictionariesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlarmDictionariesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlarmDictionary(ctx context.Context, alarmDictionaryId externalRef0.AlarmDictionaryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlarmDictionaryRequest(c.Server, alarmDictionaryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMinorVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMinorVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentManagers(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentManagersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentManager(ctx context.Context, deploymentManagerId DeploymentManagerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentManagerRequest(c.Server, deploymentManagerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInternalResourceById(ctx context.Context, resourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInternalResourceByIdRequest(c.Server, resourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocations(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocation(ctx context.Context, globalLocationId GlobalLocationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationRequest(c.Server, globalLocationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOCloudSites(ctx context.Context, params *GetOCloudSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOCloudSitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOCloudSite(ctx context.Context, oCloudSiteId OCloudSiteId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOCloudSiteRequest(c.Server, oCloudSiteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcePools(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcePoolsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcePool(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcePoolRequest(c.Server, resourcePoolId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResources(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcesRequest(c.Server, resourcePoolId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, resourcePoolId, resourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceTypes(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceType(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypeRequest(c.Server, resourceTypeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceTypeAlarmDictionary(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypeAlarmDictionaryRequest(c.Server, resourceTypeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptions(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscription(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscription(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscription(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllVersionsRequest generates requests for GetAllVersions
func NewGetAllVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/api_versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCloudInfoRequest generates requests for GetCloudInfo
func NewGetCloudInfoRequest(server string, params *GetCloudInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAlarmDictionariesRequest generates requests for GetAlarmDictionaries
func NewGetAlarmDictionariesRequest(server string, params *GetAlarmDictionariesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/alarmDictionaries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAlarmDictionaryRequest generates requests for GetAlarmDictionary
func NewGetAlarmDictionaryRequest(server string, alarmDictionaryId externalRef0.AlarmDictionaryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alarmDictionaryId", runtime.ParamLocationPath, alarmDictionaryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/alarmDictionaries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMinorVersionsRequest generates requests for GetMinorVersions
func NewGetMinorVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/api_versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentManagersRequest generates requests for GetDeploymentManagers
func NewGetDeploymentManagersRequest(server string, params *GetDeploymentManagersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/deploymentManagers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentManagerRequest generates requests for GetDeploymentManager
func NewGetDeploymentManagerRequest(server string, deploymentManagerId DeploymentManagerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deploymentManagerId", runtime.ParamLocationPath, deploymentManagerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/deploymentManagers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInternalResourceByIdRequest generates requests for GetInternalResourceById
func NewGetInternalResourceByIdRequest(server string, resourceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/internal/resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationsRequest generates requests for GetLocations
func NewGetLocationsRequest(server string, params *GetLocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationRequest generates requests for GetLocation
func NewGetLocationRequest(server string, globalLocationId GlobalLocationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "globalLocationId", runtime.ParamLocationPath, globalLocationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOCloudSitesRequest generates requests for GetOCloudSites
func NewGetOCloudSitesRequest(server string, params *GetOCloudSitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/oCloudSites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOCloudSiteRequest generates requests for GetOCloudSite
func NewGetOCloudSiteRequest(server string, oCloudSiteId OCloudSiteId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "oCloudSiteId", runtime.ParamLocationPath, oCloudSiteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/oCloudSites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcePoolsRequest generates requests for GetResourcePools
func NewGetResourcePoolsRequest(server string, params *GetResourcePoolsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcePoolRequest generates requests for GetResourcePool
func NewGetResourcePoolRequest(server string, resourcePoolId ResourcePoolId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcesRequest generates requests for GetResources
func NewGetResourcesRequest(server string, resourcePoolId ResourcePoolId, params *GetResourcesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s/resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, resourcePoolId ResourcePoolId, resourceId ResourceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s/resources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypesRequest generates requests for GetResourceTypes
func NewGetResourceTypesRequest(server string, params *GetResourceTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourceTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypeRequest generates requests for GetResourceType
func NewGetResourceTypeRequest(server string, resourceTypeId ResourceTypeId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceTypeId", runtime.ParamLocationPath, resourceTypeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourceTypes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypeAlarmDictionaryRequest generates requests for GetResourceTypeAlarmDictionary
func NewGetResourceTypeAlarmDictionaryRequest(server string, resourceTypeId ResourceTypeId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceTypeId", runtime.ParamLocationPath, resourceTypeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourceTypes/%s/alarmDictionary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionsRequest generates requests for GetSubscriptions
func NewGetSubscriptionsRequest(server string, params *GetSubscriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubscriptionRequest calls the generic CreateSubscription builder with application/json body
func NewCreateSubscriptionRequest(server string, body CreateSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubscriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSubscriptionRequestWithBody generates requests for CreateSubscription with any type of body
func NewCreateSubscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscriptionRequest generates requests for DeleteSubscription
func NewDeleteSubscriptionRequest(server string, subscriptionId SubscriptionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionRequest generates requests for GetSubscription
func NewGetSubscriptionRequest(server string, subscriptionId SubscriptionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllVersionsWithResponse request
	GetAllVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVersionsResponse, error)

	// GetCloudInfoWithResponse request
	GetCloudInfoWithResponse(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*GetCloudInfoResponse, error)

	// GetAlarmDictionariesWithResponse request
	GetAlarmDictionariesWithResponse(ctx context.Context, params *GetAlarmDictionariesParams, reqEditors ...RequestEditorFn) (*GetAlarmDictionariesResponse, error)

	// GetAlarmDictionaryWithResponse request
	GetAlarmDictionaryWithResponse(ctx context.Context, alarmDictionaryId externalRef0.AlarmDictionaryId, reqEditors ...RequestEditorFn) (*GetAlarmDictionaryResponse, error)

	// GetMinorVersionsWithResponse request
	GetMinorVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMinorVersionsResponse, error)

	// GetDeploymentManagersWithResponse request
	GetDeploymentManagersWithResponse(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagersResponse, error)

	// GetDeploymentManagerWithResponse request
	GetDeploymentManagerWithResponse(ctx context.Context, deploymentManagerId DeploymentManagerId, reqEditors ...RequestEditorFn) (*GetDeploymentManagerResponse, error)

	// GetInternalResourceByIdWithResponse request
	GetInternalResourceByIdWithResponse(ctx context.Context, resourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInternalResourceByIdResponse, error)

	// GetLocationsWithResponse request
	GetLocationsWithResponse(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*GetLocationsResponse, error)

	// GetLocationWithResponse request
	GetLocationWithResponse(ctx context.Context, globalLocationId GlobalLocationId, reqEditors ...RequestEditorFn) (*GetLocationResponse, error)

	// GetOCloudSitesWithResponse request
	GetOCloudSitesWithResponse(ctx context.Context, params *GetOCloudSitesParams, reqEditors ...RequestEditorFn) (*GetOCloudSitesResponse, error)

	// GetOCloudSiteWithResponse request
	GetOCloudSiteWithResponse(ctx context.Context, oCloudSiteId OCloudSiteId, reqEditors ...RequestEditorFn) (*GetOCloudSiteResponse, error)

	// GetResourcePoolsWithResponse request
	GetResourcePoolsWithResponse(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*GetResourcePoolsResponse, error)

	// GetResourcePoolWithResponse request
	GetResourcePoolWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*GetResourcePoolResponse, error)

	// GetResourcesWithResponse request
	GetResourcesWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetResourceTypesWithResponse request
	GetResourceTypesWithResponse(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*GetResourceTypesResponse, error)

	// GetResourceTypeWithResponse request
	GetResourceTypeWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error)

	// GetResourceTypeAlarmDictionaryWithResponse request
	GetResourceTypeAlarmDictionaryWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeAlarmDictionaryResponse, error)

	// GetSubscriptionsWithResponse request
	GetSubscriptionsWithResponse(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error)

	// CreateSubscriptionWithBodyWithResponse request with any body
	CreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	CreateSubscriptionWithResponse(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	// DeleteSubscriptionWithResponse request
	DeleteSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error)

	// GetSubscriptionWithResponse request
	GetSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error)
}

type GetAllVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.APIVersions
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAllVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudInfoResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OCloudInfo
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetCloudInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlarmDictionariesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]externalRef0.AlarmDictionary
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAlarmDictionariesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlarmDictionariesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlarmDictionaryResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.AlarmDictionary
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAlarmDictionaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlarmDictionaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMinorVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.APIVersions
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetMinorVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMinorVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentManagersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]DeploymentManager
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDeploymentManagersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentManagersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentManagerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DeploymentManager
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDeploymentManagerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentManagerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInternalResourceByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Resource
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetInternalResourceByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInternalResourceByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]LocationInfo
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LocationInfo
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOCloudSitesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]OCloudSiteInfo
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetOCloudSitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOCloudSitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOCloudSiteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OCloudSiteInfo
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetOCloudSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOCloudSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcePoolsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]ResourcePool
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcePoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcePoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcePoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResourcePool
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]Resource
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Resource
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]ResourceType
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResourceType
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypeAlarmDictionaryResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.AlarmDictionary
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceTypeAlarmDictionaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypeAlarmDictionaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]Subscription
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *Subscription
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Subscription
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllVersionsWithResponse request returning *GetAllVersionsResponse
func (c *ClientWithResponses) GetAllVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVersionsResponse, error) {
	rsp, err := c.GetAllVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllVersionsResponse(rsp)
}

// GetCloudInfoWithResponse request returning *GetCloudInfoResponse
func (c *ClientWithResponses) GetCloudInfoWithResponse(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*GetCloudInfoResponse, error) {
	rsp, err := c.GetCloudInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudInfoResponse(rsp)
}

// GetAlarmDictionariesWithResponse request returning *GetAlarmDictionariesResponse
func (c *ClientWithResponses) GetAlarmDictionariesWithResponse(ctx context.Context, params *GetAlarmDictionariesParams, reqEditors ...RequestEditorFn) (*GetAlarmDictionariesResponse, error) {
	rsp, err := c.GetAlarmDictionaries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlarmDictionariesResponse(rsp)
}

// GetAlarmDictionaryWithResponse request returning *GetAlarmDictionaryResponse
func (c *ClientWithResponses) GetAlarmDictionaryWithResponse(ctx context.Context, alarmDictionaryId externalRef0.AlarmDictionaryId, reqEditors ...RequestEditorFn) (*GetAlarmDictionaryResponse, error) {
	rsp, err := c.GetAlarmDictionary(ctx, alarmDictionaryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlarmDictionaryResponse(rsp)
}

// GetMinorVersionsWithResponse request returning *GetMinorVersionsResponse
func (c *ClientWithResponses) GetMinorVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMinorVersionsResponse, error) {
	rsp, err := c.GetMinorVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMinorVersionsResponse(rsp)
}

// GetDeploymentManagersWithResponse request returning *GetDeploymentManagersResponse
func (c *ClientWithResponses) GetDeploymentManagersWithResponse(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagersResponse, error) {
	rsp, err := c.GetDeploymentManagers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentManagersResponse(rsp)
}

// GetDeploymentManagerWithResponse request returning *GetDeploymentManagerResponse
func (c *ClientWithResponses) GetDeploymentManagerWithResponse(ctx context.Context, deploymentManagerId DeploymentManagerId, reqEditors ...RequestEditorFn) (*GetDeploymentManagerResponse, error) {
	rsp, err := c.GetDeploymentManager(ctx, deploymentManagerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentManagerResponse(rsp)
}

// GetInternalResourceByIdWithResponse request returning *GetInternalResourceByIdResponse
func (c *ClientWithResponses) GetInternalResourceByIdWithResponse(ctx context.Context, resourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInternalResourceByIdResponse, error) {
	rsp, err := c.GetInternalResourceById(ctx, resourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInternalResourceByIdResponse(rsp)
}

// GetLocationsWithResponse request returning *GetLocationsResponse
func (c *ClientWithResponses) GetLocationsWithResponse(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*GetLocationsResponse, error) {
	rsp, err := c.GetLocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationsResponse(rsp)
}

// GetLocationWithResponse request returning *GetLocationResponse
func (c *ClientWithResponses) GetLocationWithResponse(ctx context.Context, globalLocationId GlobalLocationId, reqEditors ...RequestEditorFn) (*GetLocationResponse, error) {
	rsp, err := c.GetLocation(ctx, globalLocationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationResponse(rsp)
}

// GetOCloudSitesWithResponse request returning *GetOCloudSitesResponse
func (c *ClientWithResponses) GetOCloudSitesWithResponse(ctx context.Context, params *GetOCloudSitesParams, reqEditors ...RequestEditorFn) (*GetOCloudSitesResponse, error) {
	rsp, err := c.GetOCloudSites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOCloudSitesResponse(rsp)
}

// GetOCloudSiteWithResponse request returning *GetOCloudSiteResponse
func (c *ClientWithResponses) GetOCloudSiteWithResponse(ctx context.Context, oCloudSiteId OCloudSiteId, reqEditors ...RequestEditorFn) (*GetOCloudSiteResponse, error) {
	rsp, err := c.GetOCloudSite(ctx, oCloudSiteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOCloudSiteResponse(rsp)
}

// GetResourcePoolsWithResponse request returning *GetResourcePoolsResponse
func (c *ClientWithResponses) GetResourcePoolsWithResponse(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*GetResourcePoolsResponse, error) {
	rsp, err := c.GetResourcePools(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcePoolsResponse(rsp)
}

// GetResourcePoolWithResponse request returning *GetResourcePoolResponse
func (c *ClientWithResponses) GetResourcePoolWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*GetResourcePoolResponse, error) {
	rsp, err := c.GetResourcePool(ctx, resourcePoolId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcePoolResponse(rsp)
}

// GetResourcesWithResponse request returning *GetResourcesResponse
func (c *ClientWithResponses) GetResourcesWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error) {
	rsp, err := c.GetResources(ctx, resourcePoolId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcesResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, resourcePoolId, resourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetResourceTypesWithResponse request returning *GetResourceTypesResponse
func (c *ClientWithResponses) GetResourceTypesWithResponse(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*GetResourceTypesResponse, error) {
	rsp, err := c.GetResourceTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypesResponse(rsp)
}

// GetResourceTypeWithResponse request returning *GetResourceTypeResponse
func (c *ClientWithResponses) GetResourceTypeWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error) {
	rsp, err := c.GetResourceType(ctx, resourceTypeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypeResponse(rsp)
}

// GetResourceTypeAlarmDictionaryWithResponse request returning *GetResourceTypeAlarmDictionaryResponse
func (c *ClientWithResponses) GetResourceTypeAlarmDictionaryWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeAlarmDictionaryResponse, error) {
	rsp, err := c.GetResourceTypeAlarmDictionary(ctx, resourceTypeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypeAlarmDictionaryResponse(rsp)
}

// GetSubscriptionsWithResponse request returning *GetSubscriptionsResponse
func (c *ClientWithResponses) GetSubscriptionsWithResponse(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error) {
	rsp, err := c.GetSubscriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionsResponse(rsp)
}

// CreateSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateSubscriptionResponse
func (c *ClientWithResponses) CreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) CreateSubscriptionWithResponse(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

// DeleteSubscriptionWithResponse request returning *DeleteSubscriptionResponse
func (c *ClientWithResponses) DeleteSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error) {
	rsp, err := c.DeleteSubscription(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionResponse(rsp)
}

// GetSubscriptionWithResponse request returning *GetSubscriptionResponse
func (c *ClientWithResponses) GetSubscriptionWithResponse(ctx context.Context, subscriptionId SubscriptionId, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error) {
	rsp, err := c.GetSubscription(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionResponse(rsp)
}

// ParseGetAllVersionsResponse parses an HTTP response from a GetAllVersionsWithResponse call
func ParseGetAllVersionsResponse(rsp *http.Response) (*GetAllVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.APIVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetCloudInfoResponse parses an HTTP response from a GetCloudInfoWithResponse call
func ParseGetCloudInfoResponse(rsp *http.Response) (*GetCloudInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OCloudInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAlarmDictionariesResponse parses an HTTP response from a GetAlarmDictionariesWithResponse call
func ParseGetAlarmDictionariesResponse(rsp *http.Response) (*GetAlarmDictionariesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlarmDictionariesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []externalRef0.AlarmDictionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAlarmDictionaryResponse parses an HTTP response from a GetAlarmDictionaryWithResponse call
func ParseGetAlarmDictionaryResponse(rsp *http.Response) (*GetAlarmDictionaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlarmDictionaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.AlarmDictionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetMinorVersionsResponse parses an HTTP response from a GetMinorVersionsWithResponse call
func ParseGetMinorVersionsResponse(rsp *http.Response) (*GetMinorVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMinorVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.APIVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDeploymentManagersResponse parses an HTTP response from a GetDeploymentManagersWithResponse call
func ParseGetDeploymentManagersResponse(rsp *http.Response) (*GetDeploymentManagersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentManagersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DeploymentManager
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDeploymentManagerResponse parses an HTTP response from a GetDeploymentManagerWithResponse call
func ParseGetDeploymentManagerResponse(rsp *http.Response) (*GetDeploymentManagerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentManagerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentManager
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetInternalResourceByIdResponse parses an HTTP response from a GetInternalResourceByIdWithResponse call
func ParseGetInternalResourceByIdResponse(rsp *http.Response) (*GetInternalResourceByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInternalResourceByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationsResponse parses an HTTP response from a GetLocationsWithResponse call
func ParseGetLocationsResponse(rsp *http.Response) (*GetLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LocationInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationResponse parses an HTTP response from a GetLocationWithResponse call
func ParseGetLocationResponse(rsp *http.Response) (*GetLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocationInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetOCloudSitesResponse parses an HTTP response from a GetOCloudSitesWithResponse call
func ParseGetOCloudSitesResponse(rsp *http.Response) (*GetOCloudSitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOCloudSitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OCloudSiteInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetOCloudSiteResponse parses an HTTP response from a GetOCloudSiteWithResponse call
func ParseGetOCloudSiteResponse(rsp *http.Response) (*GetOCloudSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOCloudSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OCloudSiteInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcePoolsResponse parses an HTTP response from a GetResourcePoolsWithResponse call
func ParseGetResourcePoolsResponse(rsp *http.Response) (*GetResourcePoolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcePoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourcePool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcePoolResponse parses an HTTP response from a GetResourcePoolWithResponse call
func ParseGetResourcePoolResponse(rsp *http.Response) (*GetResourcePoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourcePool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcesResponse parses an HTTP response from a GetResourcesWithResponse call
func ParseGetResourcesResponse(rsp *http.Response) (*GetResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceTypesResponse parses an HTTP response from a GetResourceTypesWithResponse call
func ParseGetResourceTypesResponse(rsp *http.Response) (*GetResourceTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceTypeResponse parses an HTTP response from a GetResourceTypeWithResponse call
func ParseGetResourceTypeResponse(rsp *http.Response) (*GetResourceTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceTypeAlarmDictionaryResponse parses an HTTP response from a GetResourceTypeAlarmDictionaryWithResponse call
func ParseGetResourceTypeAlarmDictionaryResponse(rsp *http.Response) (*GetResourceTypeAlarmDictionaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypeAlarmDictionaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.AlarmDictionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionsResponse parses an HTTP response from a GetSubscriptionsWithResponse call
func ParseGetSubscriptionsResponse(rsp *http.Response) (*GetSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSubscriptionResponse parses an HTTP response from a CreateSubscriptionWithResponse call
func ParseCreateSubscriptionResponse(rsp *http.Response) (*CreateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSubscriptionResponse parses an HTTP response from a DeleteSubscriptionWithResponse call
func ParseDeleteSubscriptionResponse(rsp *http.Response) (*DeleteSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionResponse parses an HTTP response from a GetSubscriptionWithResponse call
func ParseGetSubscriptionResponse(rsp *http.Response) (*GetSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"7v9/AAAA//8/6uYDYuUAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../common/api/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
